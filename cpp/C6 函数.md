# C6 函数
## 6.1 C++内存分区模型
程序编译后，未执行前：
1. **代码区**：存放函数体的二进制代码
2. **全局区**：  
    存放全局变量，静态变量（static），常量（字符串常量，全局常量——const修饰的全局变量）

程序执行后：  
1. **栈区**：  
   存放函数的形参，局部变量，局部常量——const修饰的局部变量。  
   由编译器自动分配和释放。
2. **堆区**：  
   由程序员分配和释放，若程序员不释放，那么程序结束时，由操作系统回收。  
   利用new关键字，可以将数据开辟到堆区；  
   利用delete关键字来释放

## 6.2 内联函数
首先，通过封装函数可以减少重复的代码，可以使程序更容易理解，可以减少重复修改，总之是好处多多。但是，也是有缺点滴。  
缺点是，调用函数比求解表达式慢很多，函数调用前需要保存寄存器，返回时恢复，也要复制实参等等。  
所以为了避免函数调用的开销，内联函数应运而生。

只需要在函数返回类型前加上关键字"**inline**"即可。如下：
```c++
inline const string &func(const string &s1){...}
```
内联函数适用的场景：用于优化小的，只有几行的，经常被调用的函数  
内联函数应该在头文件中定义。

## 6.3 引用杂谈
引用的本质————指针常量（可以改变指向的值，不可以改变指向）

常量引用通常被用来修饰形参，防止形参改变实参  
如：
```c++
inline const string &func(const string &s1){...}
```
实参的引用s1是不可以被修改的

函数千万不要返回局部对象的引用  
函数千万不要返回指向局部对象的指针

指向指针的引用，如： int *&v; v是一个指针的别名，这里要注意 * 和 & 的位次

## 6.4 函数的占位参数
比如：
```c++
void func(int i,int){...}
```
第二个int就是一个占位参数。  
占位参数的一个用途：**可用来区分前置和后置**
```c++
void operator++(){...}//对前置++操作符进行重载
void operator++(int){...}//对后置++操作符进行重载
```
